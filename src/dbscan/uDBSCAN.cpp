//
// Created by hphi344 on 10/05/24.
//
#include <omp.h>
#include "../../include/Header.h"
#include "../../include/Utilities.h"
#include "../../include/DBSCAN.h"
#include "../../include/uDBSCAN.h"

/**
This is a naive implementation of uDBSCAN++.
Note that dbscan++ uses KD Tree to speed up 1NN heuristic for cluster propagation.

vec2D_DBSCAN_Neighbor: For each sampled point, store its true neighborhood (within radius eps)
bit_CORE_POINTS: Store a bit vector presenting for core point
**/
void findCorePoints_uDbscan()
{
    vec2D_DBSCAN_Neighbor = vector<IVector> (PARAM_DATA_N, IVector());
    bit_CORE_POINTS = boost::dynamic_bitset<>(PARAM_DATA_N);

    int iNumSamples = ceil(1.0 * PARAM_DATA_N * PARAM_SAMPLING_PROB);

    chrono::steady_clock::time_point begin;
    begin = chrono::steady_clock::now();

    // Sampling points to identify core points
    random_device rd;  // a seed source for the random number engine
    mt19937 gen(rd()); // mersenne_twister_engine seeded with rd()
    uniform_int_distribution<> distrib(0, PARAM_DATA_N - 1);

    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [0, iNumSamples]
    IVector vecSamples(iNumSamples);
    for (int n = 0; n < iNumSamples; ++n)
        vecSamples[n] = distrib(gen);


    // omp_set_dynamic(0);     // Explicitly disable dynamic teams
    omp_set_num_threads(PARAM_NUM_THREADS);
    #pragma omp parallel for
    for (int s = 0; s < iNumSamples; ++s)
    {
        // Get top-k closese/furthest vectors
        int iPointIdx = vecSamples[s];
        VectorXf vecXs = MATRIX_X.col(iPointIdx);
        IVector vecNeighbor;

        // Compute distance from sampled Xn to all points in X
        for (int n = 0; n < PARAM_DATA_N; ++n)
        {
            if (n == iPointIdx)
                continue;

            float fDist = computeDist(vecXs, MATRIX_X.col(n));

            if (fDist <= PARAM_DBSCAN_EPS)
                vecNeighbor.push_back(n);
        }

        if ((int)vecNeighbor.size() >= PARAM_DBSCAN_MINPTS - 1)
        {
            bit_CORE_POINTS[iPointIdx] = 1;

//            if ( n < 1000 )
//                cout << setNeighbor.size() << endl;

            // Only need neighborhood if it is core point
            vec2D_DBSCAN_Neighbor[iPointIdx] = vecNeighbor; //.insert(vec2D_DBSCAN_Neighbor[iPointIdx].end(), vecNeighbor.begin(), vecNeighbor.end());
        }
    }

    cout << "Find core points time = " << chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - begin).count() << "[ms]" << endl;
    cout << "Number of core points: " << bit_CORE_POINTS.count() << endl;

}